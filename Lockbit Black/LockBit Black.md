This report serves as a comprehensive analysis of LockBit Black Ransomware. The majority of the analysis was done statically, and certain aspects were verified through dynamic analysis.

## Sample Used

**Malware Bazaar**: https://bazaar.abuse.ch/sample/0845a8c3be602a72e23a155b23ad554495bd558fa79e1bb849aa75f79d069194/ shared by https://twitter.com/jstrosch?s=20

**SHA256**: 0845a8c3be602a72e23a155b23ad554495bd558fa79e1bb849aa75f79d069194

## Analysis
### Dynamic API Resolving 
  First, LockBit calls **resolve_api_from_hash** to dynamically resolve the RtlCreateHeap function. The hash value is xored with a constant before being passed(the decompiler doesn't show this). 
  !["Pasted image 20230910225944.png"]("Pasted image 20230910225944.png")


  ![[Pasted image 20230910225944.png]]
  ![[Pasted image 20230910003316.png]]
  The **resolve_api_from_hash** function first resolves necessary functions like LdrLoadDll and LdrGetProcedureAddress after which it gets a pointer to the process environment block (**PEB**), and gets the **InLoadOrderModuleList** field. The **InLoadOrderModuleList** field contains the head of a doubly linked list which contains the loaded modules of the process. The malware walks **InLoadOrderModuleList** and in each iteration it gets a pointer to the BaseDllName.Buffer (**LDR_DATA_TABLE_ENTRY->BaseDllName.Buffer**) and the DllBase(**LDR_DATA_TABLE_ENTRY->DllBase**)
  ![[Pasted image 20230910010020.png]]
  In each iteration after making sure that a export directory exists for the dll, a dll name hash is calculated using the dll name from the **BaseDllName.Buffer** and a seed value of 0 which are passed to the **Calculate_Dll_Name_Hash** function. The algorithm provided below is the one used to calculate the Dll Name Hash.
  
  ![Pasted image 20230910011223.png](./Pasted image 20230910011223.png)
   My implementation of the algorithm in python.
```
def rotate_right(value, shift):
    return ((value >> shift) | (value << (32 - shift))) & 0xFFFFFFFF  
def Calculate_Dll_Name_Hash(DllName,Seed):
    hash1 = Seed
    i = 0
    DllName = DllName + "\x00"
    while(1):
        v2 = ord(DllName[i])
        if v2 >= 0x41 and v2 <=0x5A: # converts character to lowercase if     
                                       uppercase
            v2 = v2 | 0x20
            v2 = v2 & 0xFFFF
        hash1 = v2 +  rotate_right(hash1, 0xD) # rot13 
        hash1 = hash1 & 0xFFFFFFFF
        if DllName[i] == '\0':
            break
        i = i + 1
    return hash1
```

Its a simple algorithm, first the function checks if the character is uppercase and if it is it converts it to lowercase by performing an OR operation with 0x20.  In each iteration ROT 13 is performed on the seed value and the result is added to the current character value and then the result is saved back in the seed variable. One thing to note here is that one extra rotation happens because of the null byte.

![[Pasted image 20230910011533.png]]
 After the dll name hash is calculated, the DllBase of the respective dll is used to get the **NumberOfNames**, **AddressOfNames** and **AddressOfNameOrdinals**. The pointer to the name of each exported function is then passed as an argument to the **Calculate_Func_Name_Hash** function along with the Dll Name Hash which is passed as the seed value. If the return value of **Calculate_Func_Name_Hash** matches the hash passed to the function then the address of the API is calculated and returned. 
 
 The algorithm provided below is the one used to calculate the Function Name Hash.
 
![[Pasted image 20230910012828.png]]
 My implementation in python 
```
def rotate_right(value, shift):
    return ((value >> shift) | (value << (32 - shift))) & 0xFFFFFFFF  
def Calculate_Func_Name_Hash(FuncName, dllhash):
    hash1 = dllhash
    i = 0
    FuncName = FuncName + "\x00"
    while(1):
        v2 = ord(FuncName[i]) 
       
        hash1 = v2 +  rotate_right(hash1, 0xD) # rot 13
        hash1 = hash1 & 0xFFFFFFFF
        if FuncName[i] == '\0':
            break
        i = i + 1
    return hash1
```
This algorithm is again similar to the dll name hash algo, but in this there is no uppercase to lowercase conversion and the dll name hash is used as the seed value here.

#### Anti Debug Check 1

 After obtaining the address of **RtlCreateHeap**, LockBit proceeds to create a heap object using this function. It then increments the returned handle by 0x10, as this offset points to the **ForceFlags** field. Following this, LockBit performs a right shift operation on **ForceFlags** by 0x1C and then performs a bitwise OR operation with 0x4. If this operation evaluates to true, LockBit rotates the handle to the left by 1, causing the program to crash.
 ![[Pasted image 20230910232454.png]]

 When a debugger is active, the **ForceFlags** field is set to **HEAP_VALIDATE_PARAMETERS_ENABLED**, which has a value of 0x40000000. Therefore, LockBit uses this process to verify whether the **ForceFlags** field contains the flag **HEAP_VALIDATE_PARAMETERS_ENABLED** (0x40000000).

#### Resolve APIs from Hash Table 
 ![[Pasted image 20230911203732.png]]
  This function takes 4 arguments. The first one being the pointer to the structure that will hold pointers to function trampolines of each api, while the second argument is the pointer to the hash table. The first entry in the hash table is the hash of the DLL name. Different structures and hash tables are used to resolve all the required API's.
  **loaddll** loads the dll from memory or from system32 using the dll name hash xored with a constant value. After the dll is loaded, the pointer to the structure is incremented by 4 and then a check is made to see if the current hash in the hash table is equal to the delimiter(if yes the function ends), if not the function continues and the api hash from the hash table is resolved. After an api hash is resolved, 0x10 bytes are allocated using heap alloc which will hold the obfuscated api address along with the deobfuscation routine (the trampoline). The pointer to the structure and the hash table is incremented each iteration. 
  ![[Pasted image 20230910233020.png]]
#### Anti Debug Check 2
 A check is made to see if 0xABABABAB(set when process opened with a debugger) exists at the end of the allocated memory. If it exists then the pointer to the allocated memory isn't saved in the structure and this will cause the program to crash when LockBit references that address (since it would be null). 0xABABABAB is set when HEAP_TAIL_CHECKING_ENABLED is set in PEB -> NtGlobalFlag, and NtGlobalFlag is 0 by default but if the process was created by a debugger then these 3 flags will be set. 
   - `FLG_HEAP_ENABLE_TAIL_CHECK` : 0x10
   - `FLG_HEAP_ENABLE_FREE_CHECK` : 0x20
   - `FLG_HEAP_VALIDATE_PARAMETERS` :0x40
#### Obfuscate Function Address And Build a Trampoline to Deobfuscate the Address and Jump to It.
 If 0xABABABAB doesn't exist at the end of the allocated memory (trampoline) then the pointer to the allocated memory (trampoline) is saved in the structure. After this the first byte of the allocated memory (trampoline) is set to 0xB8 which is equivalent to mov eax in x86. And then a LCG is used to get a random integer between 0 and 4 and depending on the integer the method used to obfuscate the api function address(returned by **resolve_api_from_hash**) is choose and then assembly is built up in the allocated memory (trampoline) to put the obfuscated address in eax with a mov, deobfuscate it at runtime and jump to it. This process is repeated for each API in the hash table.  If an api is to be called the function trampoline of that api is called. 
 
 This conveys the same information I described above in a visual format.
 ![[Pasted image 20230912012236.png]]
 This is how different cases are implemented (read the comments)
   ![[Pasted image 20230911011648.png]]
   ![[Pasted image 20230911011736.png]]
### I have automatically labelled each API using these IDAPython scripts that I made. You can use them to automate your analysis. 
#### Anti Debug Check 3
  After all the API Hash table's have been resolved an anti debug check is implemented. **NtSetInformationThread** with the argument **ThreadHideFromDebugger** is used to hide the current thread from a debugger. If the main thread is hidden from a debugger, and a debugger is present, the process will crash.
  ![[Pasted image 20230914210428.png]]
#### Anti Debug Check 4 
  When **DebugActiveProcess**()(Enables a debugger to attach to an active process and debug it.) is called, DbgUiRemoteBreakin() is called by the debugger. 
  This anti debug check first resolves the api hash of **DbgUiRemoteBreakin** then it changes the memory protection of the first 0x20 bytes of the **DbgUiRemoteBreakin** function to **PAGE_EXECUTE_READWRITE** after which it encrypts the first 0x20 bytes of DbgUiRemoteBreakin. If a debugger was attached this will result in the program crashing as the intial bytes of DbgUiRemoteBreakin are encrypted. To bypass this, a simple solution would be to open the process with a debugger, as DbgUiRemoteBreakin is only called when a process is attached to a debugger.
  ![[Pasted image 20230914220826.png]]
  
  

   
# References
1. https://ameblo.jp/reverse-eg-mal-memo/entry-12773382057.html
2. https://blog.digital-investigations.info/2021-08-05-understanding-blackmatters-api-hashing.html
3. https://unprotect.it/technique/ntglobalflag/
4. https://anti-debug.checkpoint.com/techniques/debug-flags.html
5. https://anti-debug.checkpoint.com/techniques/interactive.html#ntsetinformationthread
6. https://anti-debug.checkpoint.com/techniques/process-memory.html#patch_ntdll_dbguiremotebreakin
7. https://unprotect.it/technique/heap-flag/
8. http://terminus.rewolf.pl/terminus/structures/ntdll/_HEAP_x86.html
9. https://research.openanalysis.net/lockbit/lockbit3/yara/triage/ransomware/2022/07/07/lockbit3.html#Shellcode
 
