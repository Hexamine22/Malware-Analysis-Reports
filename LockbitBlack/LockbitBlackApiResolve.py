# Usage ParseAPIHashTable : 1st argument path to dll_exports.json file, look at the other script for that
                            #2nd argument address of function that resolves apis from a hashtable. 
                            # Change xor key in APIName() function to the one used in your sample
import json
import idautils
import idc
import idaapi
import struct



def rotate_right(value, shift):
    return ((value >> shift) | (value << (32 - shift))) & 0xFFFFFFFF  
def Calculate_Dll_Name_Hash(DllName,Seed):
    hash1 = Seed
    i = 0
    DllName = DllName + "\x00"
    while(1):
        v2 = ord(DllName[i])
        if v2 >= 0x41 and v2 <=0x5A:
            v2 = v2 | 0x20
            v2 = v2 & 0xFFFF
        hash1 = v2 +  rotate_right(hash1, 0xD)
        hash1 = hash1 & 0xFFFFFFFF
        if DllName[i] == '\0':
            break
        i = i + 1
    return hash1
def Calculate_Func_Name_Hash(FuncName, dllhash):
    hash1 = dllhash
    i = 0
    FuncName = FuncName + "\x00"
    while(1):
        v2 = ord(FuncName[i]) 
       
        hash1 = v2 +  rotate_right(hash1, 0xD)
        hash1 = hash1 & 0xFFFFFFFF
        if FuncName[i] == '\0':
            break
        i = i + 1
    return hash1

def ResolveAPIHash(DllName, FuncName):
    dllhash = Calculate_Dll_Name_Hash(DllName, 0)
    funchash = Calculate_Func_Name_Hash(FuncName, dllhash)
    return funchash

def APIName(path, hash1):
    with open(path, 'r') as json_file:
        data = json.load(json_file)
    exported_names = data
    hash1 = int(hash1)
    hash1 = hash1 ^ 0x10035FFF
    for dll in exported_names:
        for exportfunc in exported_names[dll]:    
            exporthash = ResolveAPIHash(dll, exportfunc)    
            if exporthash == hash1:
                return exportfunc
    return 0
            
def get_xref_list(Address):
    xref_list = []
    xrefs = idautils.XrefsTo(Address)
    for addr in xrefs:
        xref_list.append(addr.frm)
    return xref_list
def get_stack_arguments(caller_addr, NoOfArgs):
    Stack = []
    PtrAddr = caller_addr
    while(1):
        PtrAddr = idc.prev_head(PtrAddr)
        if idc.print_insn_mnem(PtrAddr) == 'push':
            if idc.get_operand_type(PtrAddr, 0) == 5: #operand type 5 = Immediate Value
                Stack.append(idc.get_operand_value(PtrAddr, 0))
        if len(Stack) == NoOfArgs:
            return Stack
    
def ParseAPIHashTable(path,func_addr):
    xrefs = get_xref_list(func_addr)
    for xref in xrefs:
        arguments = get_stack_arguments(xref, 2)
        func_struct = arguments[0]
        api_hash = arguments[1]
        api_hash = api_hash + 4
        func_struct = func_struct + 4
        while(1):
            hash_dword_value = idc.get_bytes(api_hash, 4)
            hash_dword_value = struct.unpack("<I", hash_dword_value)[0]
            if hash_dword_value == 0xCCCCCCCC:
                break            
            API_Name = APIName(path, hash_dword_value)
            if API_Name == 0:
                print(f"FAIL --- Address : {hex(func_struct)}  Hash : {hash_dword_value}")
                api_hash = api_hash + 4
                func_struct = func_struct + 4
                continue
            idc.set_name(func_struct, API_Name, idaapi.SN_FORCE)
            api_hash = api_hash + 4
            func_struct = func_struct + 4
            print(f"Address : {hex(func_struct-4)}  API_Name : {API_Name}  Hash : {hash_dword_value}")
