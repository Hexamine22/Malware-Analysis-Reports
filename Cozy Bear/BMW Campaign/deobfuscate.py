import idaapi, idc, idautils

def patch_bad_bytes(inst_addr,func_start,func_end):
    valid_inst_counter = 0
    cur_ptr = func_start
    while(cur_ptr != func_end):
        if cur_ptr == inst_addr[valid_inst_counter]:
            cur_ptr = idc.next_head(cur_ptr)
            valid_inst_counter += 1
        else:
            idaapi.patch_byte(cur_ptr, 0x90)
            cur_ptr += 1        
        
def print_instructions(valid_instructions):
    pass
    """for i in range(len(valid_instructions)):
        disasm_line = idc.generate_disasm_line(valid_instructions[i], 0)
        print("{} {}".format(hex(valid_instructions[i]), disasm_line))"""

def fix_func(func_addr):
    function = ida_funcs.get_func(func_addr)
    funcend = idc.prev_head(function.end_ea)
    if idc.print_insn_mnem(func_addr) == "jmp":
        print(hex(func_addr) + "  skipped")
        return
    cur_ptr = func_addr
    stack_off = 0
    valid_instructions = []
    push_at_start = False

    while(idc.print_insn_mnem(cur_ptr) == 'push'):
        push_at_start = True
        valid_instructions.append(cur_ptr)
        stack_off += 8
        cur_ptr = idc.next_head(cur_ptr)
    if idc.print_insn_mnem(cur_ptr) == 'sub':
        if idc.get_operand_type(cur_ptr, 0) == idc.o_reg and "rsp" in idc.generate_disasm_line(cur_ptr, 0):
            if "rsp" == idaapi.get_reg_name(idc.get_operand_value(cur_ptr, 0), 8).lower(): 
                stack_off = stack_off + idc.get_operand_value(cur_ptr, 1)
                valid_instructions.append(cur_ptr)
            else:
                stack_off = 0
                valid_instructions = []
        else:
            stack_off = 0
            valid_instructions = []
    elif idc.print_insn_mnem(cur_ptr) != 'push' and push_at_start == False:
        valid_instructions = []
        stack_off = 0
        valid_instructions.append(cur_ptr)
    else:
        valid_instructions = []
        stack_off = 0
    while(1):
        cur_ptr = idc.next_head(cur_ptr)
        #print("cur ptr is " + str(get_spd(cur_ptr)))
        if cur_ptr == funcend:
            valid_instructions.append(cur_ptr)
            break
        if idc.print_insn_mnem(cur_ptr) == 'sub':
            if idc.get_operand_type(cur_ptr, 0) == idc.o_reg:
                if "rsp" in idc.generate_disasm_line(cur_ptr, 0):
                    if "rsp" == idaapi.get_reg_name(idc.get_operand_value(cur_ptr, 0), 8).lower():
                        valid_instructions.append(cur_ptr)
                        stack_off = stack_off + idc.get_operand_value(cur_ptr, 1)
        if idc.print_insn_mnem(cur_ptr) == 'add':
            if idc.get_operand_type(cur_ptr, 0) == idc.o_reg:
                if "rsp" in idc.generate_disasm_line(cur_ptr, 0):
                    if "rsp" == idaapi.get_reg_name(idc.get_operand_value(cur_ptr, 0), 8).lower():
                        valid_instructions.append(cur_ptr)
                        stack_off -= idc.get_operand_value(cur_ptr, 1)
                        if stack_off != 0:  #if stack off is not 0, mark the instructions for restoring the saved registers valid.
                            while(1):
                                cur_ptr = idc.next_head(cur_ptr)
                                valid_instructions.append(cur_ptr)
                                if cur_ptr == funcend:
                                    print_instructions(valid_instructions)
                                    patch_bad_bytes(valid_instructions,func_addr,funcend)
                                    return
                        #if stack off is zero, continue
                        continue
                    
        if idc.print_insn_mnem(cur_ptr) != 'push' and idc.print_insn_mnem(cur_ptr) != 'pop':
            if abs(get_spd(cur_ptr)) == stack_off:  # abs to convert the negative stack offset to positive
                valid_instructions.append(cur_ptr)
                    
    print_instructions(valid_instructions)
    patch_bad_bytes(valid_instructions,func_addr,funcend)
def start():
    for func in idautils.Functions():
        fix_func(func)
start()
